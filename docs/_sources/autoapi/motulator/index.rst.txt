:py:mod:`motulator`
===================

.. py:module:: motulator

.. autoapi-nested-parse::

   
   motulator: Motor Drive Simulator in Python
















   ..
       !! processed by numpydoc !!


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   control/index.rst
   model/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   helpers/index.rst
   plots/index.rst
   simulation/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   motulator.Simulation
   motulator.Mechanics
   motulator.Inverter
   motulator.FrequencyConverter
   motulator.InductionMotor
   motulator.InductionMotorSaturated
   motulator.InductionMotorInvGamma
   motulator.SynchronousMotor
   motulator.SynchronousMotorSaturated
   motulator.InductionMotorDrive
   motulator.InductionMotorDriveDiode
   motulator.SynchronousMotorDrive
   motulator.InductionMotorVHzCtrl
   motulator.InductionMotorVHzCtrlPars
   motulator.InductionMotorVectorCtrl
   motulator.InductionMotorVectorCtrlPars
   motulator.SynchronousMotorVectorCtrl
   motulator.SynchronousMotorVectorCtrlPars
   motulator.SynchronousMotorFluxVectorCtrl
   motulator.SynchronousMotorFluxVectorCtrlPars
   motulator.BaseValues
   motulator.Sequence
   motulator.Step



Functions
~~~~~~~~~

.. autoapisummary::

   motulator.abc2complex
   motulator.complex2abc
   motulator.plot
   motulator.plot_pu
   motulator.plot_extra_pu



.. py:class:: Simulation(mdl=None, ctrl=None, delay=1, enable_pwm=False, base=None, t_stop=1)

   Simulation environment.

   Each simulation object has a system model object and a controller object.



   :param mdl: Continuous-time system model.
   :type mdl: InductionMotorDrive | SynchronousMotorDrive
   :param ctrl: InductionMotorVHzCtrl
                Discrete-time controller.
   :type ctrl: SynchronousMotorVectorCtrl | InductionMotorVectorCtrl |
   :param delay: Amount of computational delays. The default is 1.
   :type delay: int, optional
   :param enable_pwm: Enable carrier comparison. The default is False.
   :type enable_pwm: bool, optional
   :param base: Base values for plotting figures.
   :type base: BaseValues, optional
   :param t_stop: Simulation stop time. The default is 1.
   :type t_stop: float, optional
















   ..
       !! processed by numpydoc !!

   .. py:method:: simulate(self, max_step=np.inf)

      
      Solve the continuous-time model and call the discrete-time controller.

      :param max_step: Max step size of the solver. The default is inf.
      :type max_step: float, optional

      .. rubric:: Notes

      Other options of solve_ivp could be easily changed if needed, but, for
      simplicity, only max_step is included as an option of this method.















      ..
          !! processed by numpydoc !!

   .. py:method:: save_mat(self, name='sim')

      
      Save the simulation data into MATLAB .mat files.

      :param name: Name for the simulation instance. The default is 'sim'.
      :type name: str, optional















      ..
          !! processed by numpydoc !!


.. py:class:: Mechanics(J=0.015, B=0, tau_L_ext=lambda t: 0)

   Mechanics subsystem.

   This models an equation of motion for stiff mechanics.

   :param J: Total moment of inertia.
   :type J: float
   :param B: Viscous damping coefficient.
   :type B: float
   :param tau_L_ext: External load torque as a function of time, `tau_L_ext(t)`.
   :type tau_L_ext: function

   ..
       !! processed by numpydoc !!

   .. py:method:: f(self, t, w_M, tau_M)

      
      Compute the state derivative.

      :param t: Time.
      :type t: float
      :param w_M: Rotor angular speed (in mechanical rad/s).
      :type w_M: float
      :param tau_M: Electromagnetic torque.
      :type tau_M: float

      :returns: Time derivative of the state vector.
      :rtype: list, length 2















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_speed(self)

      
      Measure the rotor speed.

      This returns the rotor speed at the end of the sampling period.

      :returns: **w_M0** -- Rotor angular speed (in mechanical rad/s).
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_position(self)

      
      Measure the rotor angle.

      This returns the rotor angle at the end of the sampling period.

      :returns: **theta_M0** -- Rotor angle (in mechanical rad).
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: Inverter(u_dc=540)

   Inverter with constant DC-bus voltage and switching-cycle averaging.

   :param u_dc: DC-bus voltage.
   :type u_dc: float

   ..
       !! processed by numpydoc !!

   .. py:method:: ac_voltage(q, u_dc)
      :staticmethod:

      
      Compute the AC-side voltage of a lossless inverter.

      :param q: Switching state vector.
      :type q: complex
      :param u_dc: DC-bus voltage.
      :type u_dc: float

      :returns: **u_ac** -- AC-side voltage.
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: dc_current(q, i_ac)
      :staticmethod:

      
      Compute the DC-side current of a lossless inverter.

      :param q: Switching state vector.
      :type q: complex
      :param i_ac: AC-side current.
      :type i_ac: complex

      :returns: **i_dc** -- DC-side current.
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_dc_voltage(self)

      
      Measure the DC-bus voltage.

      :returns: DC-bus voltage.
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: FrequencyConverter(L=0.002, C=0.000235, U_g=400, f_g=50)

   Bases: :py:obj:`Inverter`

   Frequency converter.

   This extends the Inverter class with models for a strong grid, a
   three-phase diode-bridge rectifier, an LC filter, and a three-phase
   inverter.

   :param L: DC-bus inductance.
   :type L: float
   :param C: DC-bus capacitance.
   :type C: float
   :param U_g: Grid voltage (line-line, rms).
   :type U_g: float
   :param f_g: Grid frequency.
   :type f_g: float

   ..
       !! processed by numpydoc !!

   .. py:method:: grid_voltages(self, t)

      
      Compute three-phase grid voltages.

      :param t: Time.
      :type t: float

      :returns: **u_g_abc** -- The phase voltages.
      :rtype: ndarray of floats, shape (3,)















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, t, u_dc, i_L, i_dc)

      
      Compute the state derivatives.

      :param t: Time.
      :type t: float
      :param u_dc: DC-bus voltage over the capacitor.
      :type u_dc: float
      :param i_L: DC-bus inductor current.
      :type i_L: float
      :param i_dc: Current to the inverter.
      :type i_dc: float

      :returns: Time derivative of the state vector, [du_dc, d_iL]
      :rtype: list, length 2















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotor(p=2, R_s=3.7, R_r=2.5, L_ell=0.023, L_s=0.245)

   Γ-equivalent model of an induction motor.

   An induction motor is modeled using the Γ-equivalent model [1]_. The model
   is implemented in stator coordinates.

   :param p: Number of pole pairs.
   :type p: int
   :param R_s: Stator resistance.
   :type R_s: float
   :param R_r: Rotor resistance.
   :type R_r: float
   :param L_ell: Leakage inductance.
   :type L_ell: float
   :param L_s: Stator inductance.
   :type L_s: float

   .. rubric:: Notes

   The Γ model is chosen here since it can be extended with the magnetic
   saturation model in a staightforward manner. If the magnetic saturation is
   omitted, the Γ model is mathematically identical to the inverse-Γ and T
   models [1]_.

   .. rubric:: References

   .. [1] Slemon, "Modelling of induction machines for electric drives," IEEE
      Trans. Ind. Appl., 1989, https://doi.org/10.1109/28.44251.

   ..
       !! processed by numpydoc !!

   .. py:method:: currents(self, psi_ss, psi_rs)

      
      Compute the stator and rotor currents.

      :param psi_ss: Stator flux linkage.
      :type psi_ss: complex
      :param psi_rs: Rotor flux linkage.
      :type psi_rs: complex

      :returns: * **i_ss** (*complex*) -- Stator current.
                * **i_rs** (*complex*) -- Rotor current.















      ..
          !! processed by numpydoc !!

   .. py:method:: torque(self, psi_ss, i_ss)

      
      Compute the electromagnetic torque.

      :param psi_ss: Stator flux linkage.
      :type psi_ss: complex
      :param i_ss: Stator current.
      :type i_ss: complex

      :returns: **tau_M** -- Electromagnetic torque.
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, psi_ss, psi_rs, u_ss, w_M)

      
      Compute the state derivatives.

      :param psi_ss: Stator flux linkage.
      :type psi_ss: complex
      :param psi_rs: Rotor flux linkage.
      :type psi_rs: complex
      :param u_ss: Stator voltage.
      :type u_ss: complex
      :param w_M: Rotor angular speed (in mechanical rad/s).
      :type w_M: float

      :returns: Time derivative of the state vector, [dpsi_ss, dpsi_rs]
      :rtype: complex list, length 2















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_currents(self)

      
      Measure the phase currents at the end of the sampling period.

      :returns: **i_s_abc** -- Phase currents.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorSaturated(p=2, R_s=3.7, R_r=2.5, L_ell=0.023, L_su=0.34, beta=0.84, S=7)

   Bases: :py:obj:`InductionMotor`

   Γ-equivalent model of an induction motor model with main-flux saturation.

   This extends the InductionMotor class with a main-flux magnetic saturation
   model [2]_::

       L_s(psi_ss) = L_su/(1 + (beta*abs(psi_ss)**S)

   :param p: Number of pole pairs.
   :type p: int
   :param R_s: Stator resistance.
   :type R_s: float
   :param R_r: Rotor resistance.
   :type R_r: float
   :param L_ell: Leakage inductance.
   :type L_ell: float
   :param L_su: Unsaturated stator inductance.
   :type L_su: float
   :param beta: Positive coefficient.
   :type beta: float
   :param S: Positive coefficient.
   :type S: float

   .. rubric:: References

   .. [2] Qu, Ranta, Hinkkanen, Luomi, "Loss-minimizing flux level control of
      induction motor drives," IEEE Trans. Ind. Appl., 2012,
      https://doi.org/10.1109/TIA.2012.2190818

   ..
       !! processed by numpydoc !!

   .. py:method:: currents(self, psi_ss, psi_rs)

      
      This method overrides the base class method.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorInvGamma(p=2, R_s=3.7, R_R=2.1, L_sgm=0.021, L_M=0.224)

   Bases: :py:obj:`InductionMotor`

   Inverse-Γ model of an induction motor.

   This extends the InductionMotor class (based on the Γ model) by providing
   the interface for the inverse-Γ model parameters. Linear magnetics are
   assumed. If magnetic saturation is to be modeled, the Γ model is preferred.

   :param p: Number of pole pairs.
   :type p: int
   :param R_s: Stator resistance.
   :type R_s: float
   :param R_R: Rotor resistance.
   :type R_R: float
   :param L_sgm: Leakage inductance.
   :type L_sgm: float
   :param L_M: Magnetizing inductance.
   :type L_M: float

   ..
       !! processed by numpydoc !!


.. py:class:: SynchronousMotor(p=3, R_s=3.6, L_d=0.036, L_q=0.051, psi_f=0.545, mech=Mechanics())

   Synchronous motor model.

   This models a synchronous motor in rotor coordinates. The default values
   correspond to a 2.2-kW permanent-magnet synchronous motor.

   :param p: Number of pole pairs.
   :type p: int
   :param R_s: Stator resistance.
   :type R_s: float
   :param L_d: d-axis inductance.
   :type L_d: float
   :param L_q: q-axis inductance.
   :type L_q: float
   :param psi_f: PM-flux linkage.
   :type psi_f: float
   :param mech: Model of the mechanical subsystem, needed only for the coordinate
                transformation in the measure_currents method.
   :type mech: Mechanics

   ..
       !! processed by numpydoc !!

   .. py:method:: current(self, psi_s)

      
      Compute the stator current.

      :param psi_s: Stator flux linkage.
      :type psi_s: complex

      :returns: **i_s** -- Stator current.
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: torque(self, psi_s, i_s)

      
      Compute the electromagnetic torque.

      :param psi_s: Stator flux linkage.
      :type psi_s: complex
      :param i_s: Stator current.
      :type i_s: complex

      :returns: **tau_M** -- Electromagnetic torque.
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, psi_s, i_s, u_s, w_M)

      
      Compute the state derivative.

      :param psi_s: Stator flux linkage.
      :type psi_s: complex
      :param u_s: Stator voltage.
      :type u_s: complex
      :param w_M: Rotor angular speed (in mechanical rad/s).
      :type w_M: float

      :returns: **dpsi_s** -- Time derivative of the stator flux linkage.
      :rtype: complex















      ..
          !! processed by numpydoc !!

   .. py:method:: meas_currents(self)

      
      Measure the phase currents at the end of the sampling period.

      :returns: **i_s_abc** -- Phase currents.
      :rtype: 3-tuple of floats















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorSaturated(p=2, R_s=0.54, i_f=0, a_d0=17.4, a_q0=52.1, a_dd=373.0, a_qq=658.0, a_dq=1120.0, S=5, T=1, U=1, V=0, mech=Mechanics())

   Bases: :py:obj:`SynchronousMotor`

   Model of a saturated synchronous motor.

   This extends the SynchronousMotor class with an analytical saturation
   model [1]_, [2]_. The permanent magnets (PMs) are assumed to be along the
   d-axis. The default values correspond to a 6.7-kW synchronous reluctance
   motor.

   :param p: Number of pole pairs.
   :type p: int
   :param R_s: Stator resistance.
   :type R_s: float
   :param i_f: Constant current corresponding to the magnetomotive force (MMF) of PMs.
               In the magnetically linear case, `i_f = psi_f/L_d`.
   :type i_f: float
   :param a_d0: Nonnegative parameter of the saturation model. In the magnetically
                linear case, `a_d0 = 1/L_d`.
   :type a_d0: float
   :param a_q0: Nonnegative parameter of the saturation model. In the magnetically
                linear case, `a_q0 = 1/L_q`.
   :type a_q0: float
   :param a_dd: Nonnegative constant defining the d-axis self-saturation together with
                `S`. In the magnetically linear case, `a_dd = 0`.
   :type a_dd: float
   :param a_qq: Nonnegative constant defining the q-axis self-saturation together with
                `T`. In the magnetically linear case, `a_qq = 0`.
   :type a_qq: float
   :param a_dq: Nonnegative constant defining the cross-saturation together with `U`
                and `V`. In the magnetically linear case, `a_dq = 0`.
   :type a_dq: float
   :param S: Nonnegative constant defining the d-axis self-saturation.
   :type S: float
   :param T: Nonnegative constant defining the q-axis self-saturation.
   :type T: float
   :param U: Nonnegative constant defining the cross-saturation.
   :type U: float
   :param V: Nonnegative constant defining the cross-saturation.
   :type V: float
   :param mech: Model of the mechanical subsystem, needed only for the coordinate
                transformation in the measure_currents method.
   :type mech: Mechanics

   .. rubric:: Notes

   The magnetomotive force (MMF) of the PMs is modeled using constant current
   source `i_f` on the d-axis [3]_. Correspondingly, this approach assumes
   that the MMFs of the d-axis current and of the PMs are in series. This
   model cannot capture the desaturation phenomenon of thin iron ribs [4]_.
   For such motors, look-up tables can be used (see scipy.interpolate).

   .. rubric:: References

   .. [1] Hinkkanen, Pescetto, Mölsä, Saarakkala, Pellegrino, Bojoi,
      “Sensorless self-commissioning of synchronous reluctance motors at
      standstill without rotor locking, ”IEEE Trans. Ind. Appl., 2017,
      https://doi.org/10.1109/TIA.2016.2644624

   .. [2] Awan, Song, Saarakkala, Hinkkanen, "Optimal torque control of
      saturated synchronous motors: plug-and-play method," IEEE Trans. Ind.
      Appl., 2018, https://doi.org/10.1109/TIA.2018.2862410

   .. [3] Jahns, Kliman, Neumann, “Interior permanent-magnet synchronous
      motors for adjustable-speed drives,” IEEE Trans. Ind. Appl., 1986,
      https://doi.org/10.1109/TIA.1986.4504786

   .. [4] Armando, Guglielmi, Pellegrino, Pastorelli, Vagati, "Accurate
      modeling and performance analysis of IPM-PMASR motors," IEEE Trans. Ind.
      Appl., 2009, https://doi.org/10.1109/TIA.2008.2009493

   ..
       !! processed by numpydoc !!

   .. py:method:: current(self, psi_s)

      
      This method overrides the base class method.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorDrive(motor=InductionMotor(), mech=Mechanics(), conv=Inverter())

   Continuous-time model for an induction motor drive.

   This interconnects the subsystems of an induction motor drive and provides
   an interface to the solver. More complicated systems could be modeled using
   a similar template.

   :param motor: Induction motor model.
   :type motor: InductionMotor | InductionMotorSaturated
   :param mech: Mechanics model.
   :type mech: Mechanics
   :param conv: Inverter model.
   :type conv: Inverter

   ..
       !! processed by numpydoc !!

   .. py:method:: get_initial_values(self)

      
      Get the initial values.

      :returns: **x0** -- Initial values of the state variables.
      :rtype: complex list, length 4















      ..
          !! processed by numpydoc !!

   .. py:method:: set_initial_values(self, t0, x0)

      
      Set the initial values.

      :param x0: Initial values of the state variables.
      :type x0: complex ndarray















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, t, x)

      
      Compute the complete state derivative list for the solver.

      :param t: Time.
      :type t: float
      :param x: State vector.
      :type x: complex ndarray

      :returns: State derivatives.
      :rtype: complex list















      ..
          !! processed by numpydoc !!

   .. py:method:: save(self, sol)

      
      Save the solution.

      :param sol: Solution from the solver.
      :type sol: Bunch object















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format and post-process them.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorDriveDiode(motor=InductionMotor(), mech=Mechanics(), conv=FrequencyConverter())

   Bases: :py:obj:`InductionMotorDrive`

   Induction motor drive equipped with a diode bridge.

   This models extends the InductionMotorDrive class with a model for a
   three-phase diode bridge fed from stiff supply voltages. The DC bus is
   modeled as an inductor and a capacitor.

   :param motor: Induction motor model.
   :type motor: InductionMotor | InductionMotorSaturated
   :param mech: Mechanics model.
   :type mech: Mechanics
   :param conv: Frequency converter model.
   :type conv: FrequencyConverter

   ..
       !! processed by numpydoc !!

   .. py:method:: get_initial_values(self)

      
      Get the initial values.

      :returns: **x0** -- Initial values of the state variables.
      :rtype: complex list, length 4















      ..
          !! processed by numpydoc !!

   .. py:method:: set_initial_values(self, t0, x0)

      
      Set the initial values.

      :param x0: Initial values of the state variables.
      :type x0: complex ndarray















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, t, x)

      
      Compute the complete state derivative list for the solver.

      :param t: Time.
      :type t: float
      :param x: State vector.
      :type x: complex ndarray

      :returns: State derivatives.
      :rtype: complex list















      ..
          !! processed by numpydoc !!

   .. py:method:: save(self, sol)

      
      Save the solution.

      :param sol: Solution from the solver.
      :type sol: Bunch object















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format and post-process them.
















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorDrive(motor=SynchronousMotor(), mech=Mechanics(), conv=Inverter())

   Continuous-time model for a synchronous motor drive.

   This interconnects the subsystems of a synchronous motor drive and provides
   an interface to the solver. More complicated systems could be modeled using
   a similar template.

   :param motor: Synchronous motor model.
   :type motor: SynchronousMotor
   :param mech: Mechanics model.
   :type mech: Mechanics
   :param conv: Inverter model.
   :type conv: Inverter

   ..
       !! processed by numpydoc !!

   .. py:method:: get_initial_values(self)

      
      Get the initial values.

      :returns: **x0** -- Initial values of the state variables.
      :rtype: complex list, length 2















      ..
          !! processed by numpydoc !!

   .. py:method:: set_initial_values(self, t0, x0)

      
      Set the initial values.

      :param x0: Initial values of the state variables.
      :type x0: complex ndarray















      ..
          !! processed by numpydoc !!

   .. py:method:: f(self, t, x)

      
      Compute the complete state derivative list for the solver.

      :param t: Time.
      :type t: float
      :param x: State vector.
      :type x: complex ndarray

      :returns: State derivatives.
      :rtype: complex list















      ..
          !! processed by numpydoc !!

   .. py:method:: save(self, sol)

      
      Save the solution.

      :param sol: Solution from the solver.
      :type sol: Bunch object















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format and post-process them.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorVHzCtrl(pars)

   V/Hz control with the stator current feedback.

   :param pars: Control parameters.
   :type pars: InductionMotorVHzCtrlPars

   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, mdl)

      
      Main control loop.

      :param mdl: Continuous-time model of an induction motor drive for getting the
                  feedback signals.
      :type mdl: InductionMotorDrive

      :returns: * **T_s** (*float*) -- Sampling period.
                * **d_abc_ref** (*ndarray, shape (3,)*) -- Duty ratio references.















      ..
          !! processed by numpydoc !!

   .. py:method:: stator_freq(self, w_s_ref, i_s)

      
      Compute the dynamic stator frequency.

      This computes the dynamic stator frequency reference used in the
      coordinate transformations.















      ..
          !! processed by numpydoc !!

   .. py:method:: voltage_reference(self, w_s, i_s)

      
      Compute the stator voltage reference.
















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorVHzCtrlPars

   
   V/Hz control parameters.
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: w_m_ref
      :annotation: :collections.abc.Callable[[float], float]

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: T_s
      :annotation: :float = 0.00025

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_s_nom
      :annotation: :float = 1.04

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: rate_limit
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_s
      :annotation: :float = 3.7

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_R
      :annotation: :float = 2.1

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_sgm
      :annotation: :float = 0.021

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_M
      :annotation: :float = 0.224

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: k_u
      :annotation: :float = 1

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: k_w
      :annotation: :float = 4

      
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorVectorCtrl(pars=InductionMotorVectorCtrlPars())

   Vector control for an induction motor drive.

   This class interconnects the subsystems of the control system and
   provides the interface to the solver.

   :param pars: Control parameters.
   :type pars: InductionMotorVectorControlPars

   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, mdl)

      
      Main control loop.

      :param mdl: Continuous-time model of an induction motor drive for getting the
                  feedback signals.
      :type mdl: InductionMotorDrive

      :returns: * **T_s** (*float*) -- Sampling period.
                * **d_abc_ref** (*ndarray, shape (3,)*) -- Duty ratio references.















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format.
















      ..
          !! processed by numpydoc !!


.. py:class:: InductionMotorVectorCtrlPars

   
   Vector control parameters for an induction motor drive.
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: w_m_ref
      :annotation: :collections.abc.Callable[[float], float]

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: sensorless
      :annotation: :bool = True

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: T_s
      :annotation: :float = 0.00025

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_c
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_o
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_s
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: tau_M_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: i_s_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_R_nom
      :annotation: :float = 0.9

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: u_dc_nom
      :annotation: :float = 540

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_s
      :annotation: :float = 3.7

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_R
      :annotation: :float = 2.1

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_sgm
      :annotation: :float = 0.021

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_M
      :annotation: :float = 0.224

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: p
      :annotation: :int = 2

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: J
      :annotation: :float = 0.015

      
















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorVectorCtrl(pars=SynchronousMotorVectorCtrlPars())

   Vector control for a synchronous motor drive.

   This class interconnects the subsystems of the control system and
   provides the interface to the solver.

   :param pars: Control parameters.
   :type pars: SynchronousMotorVectorCtrlPars

   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, mdl)

      
      Main control loop.

      :param mdl: Continuous-time model of a synchronous motor drive for getting the
                  feedback signals.
      :type mdl: SynchronousMotorDrive

      :returns: * **T_s** (*float*) -- Sampling period.
                * **d_abc_ref** (*ndarray, shape (3,)*) -- Duty ratio references.















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format.
















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorVectorCtrlPars

   
   Vector control parameters for synchronous motors.
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: w_m_ref
      :annotation: :collections.abc.Callable[[float], float]

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: sensorless
      :annotation: :bool = True

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: T_s
      :annotation: :float = 0.00025

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_c
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_fw
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_s
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: tau_M_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: i_s_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_s_min
      :annotation: :float = 0

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: k_u
      :annotation: :float = 0.95

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: w_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_s
      :annotation: :float = 3.6

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_d
      :annotation: :float = 0.036

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_q
      :annotation: :float = 0.051

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_f
      :annotation: :float = 0.545

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: p
      :annotation: :int = 3

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: J
      :annotation: :float = 0.015

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: w_o
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: zeta_inf
      :annotation: :float = 0.2

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: plot_luts(self, base)

      
      Plot control look-up tables.

      :param base: Base values for scaling the plots.
      :type base: BaseValues















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorFluxVectorCtrl(pars=SynchronousMotorFluxVectorCtrlPars())

   Flux-vector control for synchronous motor drives.

   This class interconnects the subsystems of the control system and
   provides the interface to the solver.



   :param pars: Control parameters.
   :type pars: SynchronousMotoroFluxVectorCtrlPars
















   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, mdl)

      
      Main control loop.

      :param mdl: Continuous-time model of a synchronous motor drive for getting the
                  feedback signals.
      :type mdl: SynchronousMotorDrive

      :returns: * **T_s** (*float*) -- Sampling period.
                * **d_abc_ref** (*ndarray, shape (3,)*) -- Duty ratio references.















      ..
          !! processed by numpydoc !!

   .. py:method:: post_process(self)

      
      Transform the lists to the ndarray format.
















      ..
          !! processed by numpydoc !!


.. py:class:: SynchronousMotorFluxVectorCtrlPars

   
   Control parameters: flux-vector control for synchronous motor drives.
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: w_m_ref
      :annotation: :collections.abc.Callable[[float], float]

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: sensorless
      :annotation: :bool = True

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: T_s
      :annotation: :float = 0.00025

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_s_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_s_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_s_min
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: k_u
      :annotation: :float = 0.9

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_psi
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_tau_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: alpha_s
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: tau_M_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: i_s_max
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: R_s
      :annotation: :float = 3.6

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_d
      :annotation: :float = 0.036

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: L_q
      :annotation: :float = 0.051

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: psi_f
      :annotation: :float = 0.545

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: p
      :annotation: :int = 3

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: J
      :annotation: :float = 0.015

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: w_o
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: zeta_inf
      :annotation: :float = 0.2

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: g
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!


.. py:class:: BaseValues

   
   Base values.

   Base values are computed from the nominal values and the number of pole
   pairs. They can be used, e.g., for scaling the plotted waveforms.















   ..
       !! processed by numpydoc !!
   .. py:attribute:: U_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: I_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: f_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: P_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: tau_nom
      :annotation: :float

      
















      ..
          !! processed by numpydoc !!

   .. py:attribute:: p
      :annotation: :int

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: __post_init__(self)

      
















      ..
          !! processed by numpydoc !!


.. py:function:: abc2complex(u)

   
   Transform three-phase quantities to a complex space vector.

   :param u: Phase quantities.
   :type u: array_like, shape (3,)

   :returns: Complex space vector (peak-value scaling).
   :rtype: complex

   .. rubric:: Examples

   >>> y = abc2complex([1, 2, 3])
   >>> y
   (-1-0.5773502691896258j)















   ..
       !! processed by numpydoc !!

.. py:function:: complex2abc(u)

   
   Transform a complex space vector to three-phase quantities.

   :param u: Complex space vector (peak-value scaling).
   :type u: complex

   :returns: Phase quantities.
   :rtype: ndarray, shape (3,)

   .. rubric:: Examples

   >>> y = complex2abc(1-.5j)
   >>> y
   array([ 1.       , -0.9330127, -0.0669873])















   ..
       !! processed by numpydoc !!

.. py:class:: Sequence(times, values, periodic=False)

   Sequence generator.

   This represents a sequence generator. The time array must be increasing.
   The output values are interpolated between the data points.



   :param times: Time values.
   :type times: ndarray
   :param values: Output values.
   :type values: ndarray
   :param periodic: Enables periodicity. The default is False.
   :type periodic: bool, optional
















   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, t)

      
      Interpolate the output.

      :param t: Time.
      :type t: float

      :returns: Interpolated output.
      :rtype: float or complex















      ..
          !! processed by numpydoc !!

   .. py:method:: __str__(self)

      
      Return str(self).
















      ..
          !! processed by numpydoc !!


.. py:class:: Step(step_time, step_value, initial_value=0)

   Step function.



















   ..
       !! processed by numpydoc !!

   .. py:method:: __call__(self, t)

      
      Step function.

      :param t: Time.
      :type t: float

      :returns: Step output.
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: __str__(self)

      
      Return str(self).
















      ..
          !! processed by numpydoc !!


.. py:function:: plot(sim)

   
   Plot example figures in SI units.

   :param sim: Should contain the simulated data.
   :type sim: Simulation object















   ..
       !! processed by numpydoc !!

.. py:function:: plot_pu(sim)

   
   Plot example figures in per units.

   :param sim: Should contain the simulated data.
   :type sim: Simulation object















   ..
       !! processed by numpydoc !!

.. py:function:: plot_extra_pu(sim, t_zoom=(1.1, 1.125))

   
   Plot extra waveforms for a motor drive with a diode bridge.

   :param sim: Should contain the simulated data.
   :type sim: Simulation object
   :param t_zoom: Time span. The default is (1.1, 1.125).
   :type t_zoom: 2-tuple, optional















   ..
       !! processed by numpydoc !!

